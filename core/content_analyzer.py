"""
vidgen content analyzer module

analyzes pdf content and creates structured video segments.
uses openai to intelligently break content into digestible video sections
and matches images to appropriate segments.
"""

import json
from typing import List, Dict, Optional
from openai import OpenAI
from jinja2 import Environment, FileSystemLoader, select_autoescape
from pathlib import Path
from pydantic import BaseModel
from utils.logger import get_logger

logger = get_logger(__name__)


class SegmentImage(BaseModel):
    """Pydantic model for segment image."""
    source: str  # "pdf", "stock", or "ai_generated"
    query: Optional[str] = None  # search keyword if stock, or prompt if ai_generated
    path: Optional[str] = None  # path to pdf image if pdf, or path to generated image if ai_generated


class VideoSegment(BaseModel):
    """Pydantic model for a video segment."""
    title: str
    purpose: str
    content: str
    key_points: List[str]
    visual_keywords: List[str]
    duration: int
    image: Optional[SegmentImage] = None  # image to show with segment


class VideoOutline(BaseModel):
    """Pydantic model for video outline."""
    title: str
    total_segments: int
    estimated_duration: int
    segments: List[VideoSegment]


class ContentAnalyzer:
    """analyze and structure pdf content for video creation."""
    
    def __init__(self, api_key: Optional[str] = None, target_segments: int = 7, 
                 segment_duration: int = 45, prompts_dir: Optional[Path] = None):
        """
        initialize content analyzer.
        args:
            api_key: openai api key
            target_segments: target number of video segments
            segment_duration: target duration per segment in seconds
            prompts_dir: path to prompts directory (from config)
        """
        self.api_key = api_key
        # initialize openai client
        self.client = OpenAI(api_key=self.api_key)
        # set target segments and segment duration
        self.target_segments = target_segments
        self.segment_duration = segment_duration
        # set openai model
        self.model = "gpt-4o-2024-08-06"
        
        # Initialize jinja2 environment for prompt templates
        if prompts_dir is None:
            from utils.config_loader import get_config
            config = get_config()
            prompts_dir = config.get_prompts_directory()
        
        self.prompts_dir = prompts_dir
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(prompts_dir)),
            autoescape=select_autoescape(['html', 'xml'])
        )
    
    def analyze_content(self, document_title: str, chunks: List[Dict], 
                       images_metadata: Optional[List[Dict]] = None) -> Dict:
        """analyze pdf content and create video segments."""
        logger.info("starting content analysis")
        
        # create video outline (image matching is now handled by the model)
        outline = self._create_video_outline(document_title=document_title, 
                                             chunks=chunks,
                                             images_metadata=images_metadata or [])
        
        # convert image field to backward-compatible format
        outline = self._convert_image_format(outline)
        
        logger.info(f"created {len(outline['segments'])} video segments")
        
        return outline

    def _generate_summary(self, prompt: str) -> str:
        """
        utility method to generate summary/outline using openai API.
        Args:
            prompt: the prompt string to send to the model.
        returns:
            the text response generated by openai (JSON string).
        throws:
            exception on openai API error.
        """
        # load system prompt from template
        system_template = self.jinja_env.get_template('outline_system.j2')
        system_prompt = system_template.render()
        
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": system_prompt
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=2000,
            response_format={"type": "json_object"}
        )
        return response.choices[0].message.content
    
    def _create_video_outline(self, document_title: str, chunks: List[Dict],
                             images_metadata: List[Dict]) -> Dict:
        """create structured video outline from chunks."""
        logger.info("creating video outline with ai model")
    
        
        # create outline prompt
        prompt = self._create_outline_prompt(
            document_title,
            chunks,
            images_metadata,
            self.target_segments,
            self.segment_duration
        )
        
        try:
            outline_json = self._generate_summary(prompt)
            outline = self._parse_outline_json(outline_json=outline_json, 
                                               document_title=document_title)
            
            logger.info("successfully created video outline")
            return outline
            
        except Exception as e:
            logger.error(f"error creating outline: {str(e)}", exc_info=True)
            raise Exception(f"error creating outline: {str(e)}")
    
    def _parse_outline_json(self, outline_json: str, document_title: str) -> Dict:
        """
        parse json outline into structured format using pydantic.
        args:
            outline_json: json string from ai
            document_title: title of the document
        returns:
            structured outline dictionary
        """
        try:
            # parse json string
            outline_data = json.loads(outline_json)
            
            # validate and parse with pydantic
            outline_model = VideoOutline(**outline_data)
            
            # convert to dict and add missing fields for backward compatibility
            outline_dict = outline_model.model_dump()
            
            # ensure title matches
            if not outline_dict.get('title'):
                outline_dict['title'] = document_title
            
            # validate minimum segments
            if outline_dict['total_segments'] < 3:
                logger.warning("outline has too few segments, using fallback")
                raise ValueError("Too few segments generated")
            
            return outline_dict
            
        except json.JSONDecodeError as e:
            logger.error(f"failed to parse json: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"failed to validate outline structure: {str(e)}")
            raise
    
    
    def _create_outline_prompt(self, title: str, chunks: List[Dict], 
                               images_metadata: List[Dict],
                               target_segments: int, duration: int) -> str:
        """create prompt for video outline generation.
        args:
            title: title of the document
            chunks: list of chunks
            images_metadata: list of available images from pdf
            target_segments: target number of video segments
            duration: target duration per segment in seconds
        returns:
            prompt for video outline generation
        """
        
        chunks_text = "\n\n".join([
            f"Summary: {chunk['summary']}\n Context: {chunk['chunk']}"
            for chunk in chunks[:10]  # limit to first 10 chunks to avoid context window issues
        ])
        
        # format images metadata for prompt
        images_text = ""
        if images_metadata:
            images_list = []
            for img in images_metadata:
                img_info = f"""Image ID: {img.get('index_on_page', 'unknown')}
                                Label: {img.get('label', 'N/A')}
                                Description: {img.get('description', 'N/A')}
                                Type: {img.get('image_type', 'N/A')}
                                Key Elements: {', '.join(img.get('key_elements', []))}
                                Filepath: {img.get('filepath', 'N/A')}
                                Page: {img.get('page_number', 'N/A')}
                                Relevance: {img.get('ai_relevance', 'medium')}"""
                images_list.append(img_info)
            images_text = "\n\n".join(images_list)
        
        # load and render template
        template = self.jinja_env.get_template('outline_instruction.j2')
        prompt = template.render(
            title=title,
            target_segments=target_segments,
            duration=duration,
            chunks_text=chunks_text,
            images_text=images_text,
            has_images=len(images_metadata) > 0
        )
        
        return prompt
    

    def _convert_image_format(self, outline: Dict) -> Dict:
        """
        convert image field to backward-compatible format.
        args:
            outline: video outline with image field
        returns:
            outline with pdf_images and stock_image_query fields
        """
        for segment in outline['segments']:
            # initialize backward-compatible fields
            segment['pdf_images'] = []
            segment['stock_image_query'] = None
            
            # convert image field if present
            if segment.get('image'):
                img = segment['image']
                if img['source'] == 'pdf' and img.get('path'):
                    # add to pdf_images list
                    segment['pdf_images'] = [{'filepath': img['path']}]
                elif img['source'] == 'stock' and img.get('query'):
                    # set stock_image_query
                    segment['stock_image_query'] = img['query']
        
        return outline
    
    def save_outline(self, outline: Dict, output_path: str):
        """
        save outline to json file.
        args:
            outline: video outline
            output_path: path to save json
        """
        with open(output_path, 'w') as f:
            json.dump(outline, f, indent=2)
        
        logger.info(f"saved outline to {output_path}")




